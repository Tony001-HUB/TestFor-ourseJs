1)
добавляем удаленный репозиторий
git remote add origin https://github.com/Tony001-HUB/TestFor-ourseJs.git


2)
Выход из ситуации (к примеру без комментария окошко с ~ ~ ~ ~ ) -> ctrl + c(два раза) -> :wq! 


3) ? тернарный оператор(((т.к. в его работе участвуют 3 элемента 1)условие 2)если да 3) если нет )
(num == 40) ? console.log("ok") : console.log("error")


4) +(унарный плюс) перед string делает типа num - число
+"40" 


5)callback-функции, вызываются только после определенного действия, в нашем случаее после вызова функции. К примеру 
на серваке задержка и нам надо чтобы первая функция отработала первой, а вторая за ней, но из за задержки 
может получиться наоборот и тут поможет callback -функции.

function learnJS(lang, callback){
    console.log(`я учу ${lang}`);
    callback();
}

learnJS('JS', function(){console.log('я прошёл этот урок');}); //тут анонимная функция
ИЛИ
learnJS('JS', done); //тут именная функция(БЕЗ КРУГЛЫХ СКОБОК!!!)
function done(){
    console.log(`я прошёл этот урок`);
}


6)Перебор объекта 

//где options - объект;
fot (let key in options){
	
	console.log(`Свойство ${key} имеет значение ${options[key]}`);
}


7)Перебор объекта, когда есть вложенный объект

const personalMovieDB = {
    count: numberOfFilms,
    movies: { name: ""}  //сюда достучаться
};
fot (let key in personalMovieDB){

	if(typeOf(personalMovieDB[key]) == 'object')
    {
        fot (let i in personalMovieDB[key])
        {
            console.log(`Свойство ${i} имеет значение ${options[key][i]}`);
        }
    }
    else
    {
        console.log(`Свойство ${key} имеет значение ${options[key]}`);
    }
}


8) Из объекта массив сделать 

Object.keys(nameObj);


9) Копирование объектов 1.Поверхносная копия(без вложеного объекта в объект)
//объект для копирования
const numbers = {
    a: 5,
    b: 10,
    c: 20,
    doubleNum: { //вложенный
        i: 5.5
    }
}

function copy(mainObj){
    let copyObj = {}; //объект куда копируем

    let key;
    for (key in mainObj){
        copyObj[key] = mainObj[key];
    }

    return copyObj;
}

const newNum = copy(numbers); // из numbers в newNum
newNum.a = 10; // изменяем объект 

console.log(numbers);
console.log(newNum);




10) Копирование объектов 2.Глубокая копия(с вложеным объектом в объект) БУДЕТ ПОЗЖЕ



11) Объединение двух объектов на основе одного из двух. 

Object.assign(куда, откуда); // в конец добавляет


12) Копирование объектов при помощи функции с возможностью изменения

const num = {
    a: 10
};
const clone = Object.assign({}, num); // копирование объекта в новый объект с возможностью изменения
clone.a = 20; //a = 20 

console.log(num);
console.log(clone);


13) При работе с массивами применяе функцию newArr = oldArr.slice(); (старый метод)
Новый стандарт позволяет копировать массивы таким образом: спрэд оператор ...
const video = ['leo', 'doorPop'],
      music = ['Makc krch'],
      inet = [...video, ...music]; //слияние


14) Передача в функцию параметров через массив при помощи спрэд оператор ...

function log(a, b , c){
    console.log(a);
    console.log(b);
    console.log(c);
}

const num = [2, 5 ,9];

log(...num);



15) Копирование объекта при помощи спрэд оператор ...

const q = {
    a: 'wertot'
}

const copy = {...q};



16) Варианты "наследования" у объектов свойств 

let warrior = {
    armor: 100
}

let tony = {
    attack: 500
}
tony.__proto__ = warrior; 
Object.setPrototypeOf(tony, warrior);
const john = Object.create(warrior); 


17) Динамическая типизация: 0, '', NaN, null, undef - false; Всё остальное - true; !! - к типу bool


18)Работа с событиями, отмена стандартоного поведения браузера 
const link = document.querySelectorAll('.btn');

link.addEventListener('click', (event) => {
    event.preventDefault(); //говорим, что будет по другому обрабатывать ивент кнопки
    console.log(event.target());
});


19) Получить все дочерние елементы body. 
console.log(document.body.childNodes);
ИЛИ
console.log(document.querySelector('.btn').parentNode);



20) Работа с селекторами страницы + получение следующего элемента после него 

console.log(document.querySelector('[curent-item = "3"]').nextElementSibling);



21) Дождаться полной DOM загрузки элементов
document.addEventListener('DOMContentLoaded', () => {});


22) defer - загрузка скрипта в фоновом режиме. и выполнится сразу после того, как будет готово DOM ДЕРЕВО.
и можно загружать скрипт в начале body и даже head


23) async - в отличии от defer не ждет загрузки остальных скриптов (которые стоят до него). Так же ждет загрузки 
DOM ДЕРЕВа.


/***************************************** ПРАКТИКА 24)

//получить класс под определённым индексом
const allBtns = document.querySelectorAll('button')
      wrapper = document.querySelector('.btn-block');

/*
console.log(allBtns[0].classList.item(0));

//добавить класс кнопке можно через , добавлять
console.log(allBtns[0].classList.add('red'));

//удалить класс
console.log(allBtns[0].classList.remove('red'));


//тоглить классы, то есть если он есть - удалим
//а если его нет - то добавится
console.log(allBtns[0].classList.toggle('red'));


//проверим, на наличие класса
if(allBtns[1].classList.contains('red')){
    console.log('данный класс существует');
}
*/

//пример работы появления бургерного меню с добавлением и удалением класса.

allBtns[0].addEventListener('click', () => {
    /* //подробно:
    if(!allBtns[1].classList.contains('red'))
    {
        allBtns[1].classList.add('red');
    } else{
        allBtns[1].classList.remove('red');
    }
    */
    // так круче:
    allBtns[1].classList.toggle('red');
});


// ДЕЛЕГИРОВАНИЕ. Реагирует только тогда когда у элемента есть класс contains('blue')
wrapper.addEventListener('click', (event) => {
    if(event.target && event.target.classList.contains('blue')){
        console.log('HELLO');
    }

});

//второй вариант через matches('button.red'), его like сотрудники googl'а
wrapper.addEventListener('click', (event) => {
    if(event.target && event.target.matches('button.red')){
        console.log('HELLO');
    }

});

/*********************************************************************************

25) Контекст вызова функции .this

function showThis(){
    console.log(this); 
}
//обычная функция this = window

const obj = {
    a: 5,
    b: 9,
    sum: function(){
        console.log(this);
    }
};
obj.sum();
// такой this выведет весь объект

function sayName(){
    console.log(this.nane);
}

const user = {
    name: 'John'
};

sayName.call(user);
//ручное присвоение контекста This


function count(num){
    return this * num;
}

const double = count.bind(2);
console.log(double);
// привязка контекста припомощи функции bind



!!Стрелочная функция ссылается на своего родителя, а просто функция на элементпокоторому кликаем



26) оператор rest 
function log(a, b, ...rest) {
    console.log(a, b , rest);
}

log('a', 'b', 5555, '777', 6789);
//почему-то не работает с нулями(000);


27)
const person = {
 name: 'Pop',
 age: 30,
 lastName: {
    nameL: 'KEKLOL'
 }
};

//console.log(JSON.parse(JSON.stringify(person))); // конверт к json(stringify) из (parse)

//глубокое копирование объекта не зависимого от person, при изменении
const clone = JSON.parse(JSON.stringify(person));
clone.lastName.nameL = 'LOLKEK';

console.log(person);
console.log(clone);


//***** КУРСЫ БОРИС *////// ПРОТОТИПЫ ПОД КОПОТОМ ЛОГИКА!!!

У каждой функции-конструктора есть свой конструктор по умолчания 
{
   constructor: SayHello

}

создавая прототип так SayHello.prototype {test(){}} мы перезаписываем конструктор 
надо так: SayHello.prototype.test(через точку указывать метод)

НЕЛЬЗЯ:
SayHello.prototype = {
   test: function() {...},
   testTwo: function() {...}
}
НАДО:
SayHello.prototype.test
SayHello.prototype.testTwo

//
const obj = new SayHello('1');
const obj1 = new obj.constructor('2');
- SayHello.prototype является прототипом объекта obj;
- SayHello.prototype содержит свойство constructor
- obj ссылается на constructor
Вызвать на obj1 конструктор obj

просуммируем:
- SayHello.prototype - это объект, который будет прототипом для всех объектов, которые создала функция SayHello;
- SayHello.prototype содержит свойство constructor, которое ссылается на функцию SayHello;
- Получается, что через свойство constructor мы можем обращаться к функции SayHello;
obj.constructor == SayHello

Борис, [03.02.21 17:53]
function Person(name) {
   this.name = name;
}
Person.prototype.eat = function() { ... }

function Student(name, faculty, university) {
     Person.call(this, name); // все равно, что super в классах

     this.faculty = faculty;
     this.university = university;
}
Student.prototype.work = function() { ... }
Student.prototype.__proto__ = Person;

Борис, [03.02.21 17:53]
сейчас будем разбираться, как это работает

Борис, [03.02.21 17:55]
Person.call(this, name); - это вызов родительской функции конструктора. 
Мы говорим функции Person:
"у нас есть объект-студент, добавь ему имя"

Первым параметром в call мы указываем, кто будет this'ом внутри функции Person.
Внутри функции Person this'ом будет наш объект-студент. Ему добавится свойство name.

Борис, [03.02.21 17:58]
Логика работы примерно такая:
...
function Student(name, faculty, university) {
     Person.call(this, name); // 1

     this.faculty = faculty; // 2
     this.university = university; // 3
}
...
const student = new Student('Vasya', 'Math', 'Geneva');



1 -> this выглядит так: 
{name: 'Vasya'}
2 -> this выглядит так: 
{name: 'Vasya', faculty: 'Math'}
3 -> this выглядит так: 
{name: 'Vasya', faculty: 'Math', university: 'Geneva'}

Борис, [03.02.21 17:59]
Важно понять: на шаге 1 мы попросили функцию Person обработать нашего студента - добавить ему свойство name

Tony Osipenko, [03.02.21 18:01]
понял) можно тогда  this.name = name; this.birth = birth; в Employee не писать, а просто     Person.call(this, ... , ...);

Борис, [03.02.21 18:01]
да)

Борис, [03.02.21 18:01]
это удобно, когда Person добавляет не одно свойство, а 50


//***** КУРСЫ БОРИС *////// ПРОТОТИПЫ ПОД КОПОТОМ ЛОГИКА!!!